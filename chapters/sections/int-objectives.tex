%!TEX root = ../../dissertation.tex

\section{Project objectives} % (fold)
\label{sec:project_objectives}


Nowadays new cities are being built  completely from scratch. An example of these cities is the city of Maasdar\footnote{\url{http://www.masdar.ae/en/masdar/detail/masdar-city-free-zone}} in Abu Dhabi. This city, designed by Foster and Partners, is currently being built in the desert at an estimated cost between 18 and 19 billion US\$. Whoever is responsible for a project of this size can not afford to make any mistakes.
To designs this projects it is necessary to create models, but in contrast to the relatively small size of a model of a single building, in this situations an entire city has to be modeled. Therefore, it requires generation and visualization of very large amounts of geometry.

The overall goal of our work is to build a GD tool that solves the performance problems that raise with the generation and visualization of large amounts of geometry. It should be an easy to use tool, with very high performance that will be focused on model visualization, avoiding features regarding interactive model manipulation.

It also should be able to support Immediate Feedback, i.e. allow the users to quickly see the results of the changes they make, for much larger models than the current GD tools can handle. This system should also provide a significant amount of geometric primitives such as \emph{boxes}, \emph{cylinders} or \emph{spheres} that will allow users to model a large variety of shapes.

It will also provide a programming interface, that is how users will interact with the system. It should be simple and easy understand, yet broad and powerful to give the users freedom to create. This will be the visible part of the system together with the visualization window.

After, there is the \textbf{GPU communication} module that implement the functions provided. This module will generate the geometry description, create the windows and transfer the data to the GPU. This module will implement a set of techniques that will 

The \textbf{GPU pipeline} is where the geometry will be generated and is explained in Section~\ref{sub:modern_opengl}.


This work is being developed in the context of the Rosetta that is also a GD tool that helps architects and designers to develop their work procedurally. Rosetta is an extensible IDE based on \textbf{DrRacket} and built in Racket. 

In this context the module will act as a fast preview mode that allows the users to rapidly see the changes they make on their model during their creative process.

On the next section will be explained the architecture of our proposed solution.


This work proposes a solution to this problem and aim to generate large volumes of geometry that is as close as possible to real-time. It does so by jumping over some steps while drastically decreasing the amount of data that is transfered between steps. First we aim to get the geometry as fast as possible to the GPU, so since our goal is just visualization, we jump the CAD layer, eliminating the first communication steps. Another action is to reduce the amount of data that is transferred, by transferring only a very concise description of the geometry, generating the actual geometry on the GPU.
To improve visualization performance, techniques such as Level Of Detail (Section~\ref{ssub:level_of_detail}) and Occlusion Culling (Section~\ref{ssub:occlusion_culling}) are explored.

The processing work for the generation and visualization of the geometry is shared between the \gls{CPU} and the \gls{GPU}. Happens that the work load can be splitted between this two elements in various different ways. And we explore some different ways to aim to have the best performance possible.
The most common solutions assign the large part of the load to the \gls{CPU}, that is responsible for fully generate the geometry which is then sent to the \gls{GPU} that just does pay off.

The simplest and most used load distribution is to assign a large part of it to the \gls{CPU}, where all the geometry is generated which results in a polygon mesh that is fed to the \gls{GPU}. The \gls{GPU} just renders the final result without any processing of the geometry.

It is also possible to give some of the work to the \gls{GPU}. This is done taking advantage of the programmable \gls{GPU}s, where we can use their processing power to manipulate or generate geometry. The \gls{GPU} is able to execute programs, called shaders, that are able to manipulate the geometry that is generated by the \gls{CPU}. With this method, the geometry is generated by the \gls{CPU} but it is changed by the \gls{GPU}. The \gls{GPU} is able to improve detail of the meshes or implement light effects, among other things.

One alternative to the last distribution is to assign a larger part of the processing work to \gls{GPU}. With this distribution the \gls{CPU} creates concise descriptions of the geometry, which is lighter work load, and the \gls{GPU} is responsible for the amplification of the geometry from the descriptions.

The last alternative is to assign most of the work to the \gls{GPU}. With this method, the program that generates the geometry is fully executed by the \gls{GPU}. It is the option that is more complex since all the code have to be written or translated to shader code. Because it runs only on the \gls{GPU}, we can take advantage of the large number of processors that the \gls{GPU}s currently have, and with that get performance improvements.


% section project_objectives (end)